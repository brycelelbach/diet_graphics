<pre class='metadata'>
Title: Diet Graphics
Abstract: The proposed 2D graphics library is not a good fit for C++.
Shortname: D1062
Revision: 0
Audience: WG21
Status: D
Group: WG21
URL: http://wg21.link/P1062r0
Editor: Bryce Adelstein Lelbach, NVIDIA, brycelelbach@gmail.com
Editor: Olivier Giroux, NVIDIA, ogiroux@nvidia.com
Editor: Corentin Jabot, corentinjabot@gmail.com
Date: 2018-05-07
Markup Shorthands: markdown yes
</pre>

# Questionable Utility

Before we dive into the details, let's take a step back and discuss **why** some on the committee have a desire to standardize a C++ 2D graphics library.

A few different use cases have been espoused during the lifetime of this proposal:

* Improving the teachability of C++.
* Providing graphics programmers with a standard 2D graphics API.

## Teaching

Some of the motivation behind the proposed C++ 2D graphics interface is a desire to provide a powerful teaching tool for C++.
For new programmers, especially younger programmers, writing command line applications may not be particularly intuitive or exciting
Being able to see and interact with your code is far more natural.
Building graphical applications can help the student connect the code they are writing to the real world.
After all, most non-programmers primarily interact with software that has a graphical interface of some sort.

But why does this need to be in the standard?
There are, of course, many high-quality 3rd party C++ libraries that provide these features.
But, C++ also lacks a standard build system, packing system and a centralized source of packages.
This can make it notably more difficult to start using, say, a 3rd party 2D graphics library in C++.

A common criticism of C++ is that the C++'s standard library is not as rich as the core libraries of other languages such as Java, Python, Javascript, Rust, Swift, etc.

For example, C++ does not have:

* A Unicode text library.
* A HTML library.
* A JSON library.
* Database libraries.
* **TODO**

But is the answer to that to try and standardize everything?
Many languages with diverse library ecosystems have them because they have package manager.

It is also questionable if the proposed C++ 2D graphics interface actually facilitates teaching.

Let's consider an example. Suppose you are teaching a group of teenagers with no programming experience how to program in C++.
There are a number of common starting points for young programmers, such as robotics, but let's consider the one that is likely most popular: building a simple game.

Suppose we want our students to start by building a simple animation (later, we'll add keyboard input in to make it a game) where a single character moves around on a 2D screen.

Where do we start?

* First, they need to get a window, and a surface in that window that they can draw in.
* Then, they need to programmatically place the character sprite on the screen at some starting position. The character sprite could be represented as an instance of a class type, whose constructor puts it in the starting position,
* Next, they'll want to move the character sprite around by progamtically updating its position and redrawing the screen. This could be done by adding methods to the character sprite class: `move_left`, `move_right`, `move_up`, `move_down`, etc.

Eventually, we'd want to replace the static animation with movement based on keyboard input.
Then we would add other sprites (other characters, obstacles, etc) and game logic for how they would interact.

What we're doing in this curriculum is **teaching programming in C++ using graphics**.

This is not something that the proposed C++ 2D graphics interfaces enables.
The proposed C++ 2D graphics interface gives you a mechanism to **programmatically draw graphics using C++".
For example, you could programmatically draw the character sprite in the above example.

But, why would you want to have students do this?
The drawing of the character is not what we want to focus on; instead we want to build application logic that programmatically manipulates different objects (**assets**) on a surface.
Instead of drawing assets programmatically in C++, we could have the students use an image editting tool to create an image (JPG, SVG, etc) to use as their sprite.

Drawing even simple images with the proposed C++ 2D graphics library is verbose and thus distracting.
If one was to design a curriculum around this proposal, students will have to learn a lot about computer graphics.
Our goal is for students to learn C++ programming; graphics should be a teaching aid, not the main focus.

We question whether a drawing library would be a useful teaching aid.
It seems like a simple facility for building graphical interfaces that supports and leverages established graphics standards and formats and allos programmers can use common image editting tools to generate art assets instead of having to express them programmatically in C++.
 
## Enabling Graphics Programmers

There are many professional graphics programmers and who use C++, so it is natural for the committee to consider ways to help them.

There are two classes of graphics programmers:

* **Graphical Application Developers (Non-Experts)** build graphics applications, such as games. They are mainly concerned with developing application logic that manipulates graphics asset but they do not typically programmatically building the assets. The assets they work with are developed using some **asset toolchain** that generates assets in common formats such as Postscript or SVG by either the graphical application developers or artists that they collaborate with.
* **Graphical Framework Developers (Experts)** build graphics frameworks, engines, and libraries that graphical applicaiton developers use.

Naturally, there are many more graphical application developers than there are framework developers.

### Graphical Application Developers

Graphical application developers are application programmers who build (usually interactive) software which displays visual output.
Some examples include games, cartography software, and scientific visualization.
Most graphical application developers do not regularly produce the art assets they use programmatically.
Instead, they consume assets produces upstream by artists, taken from databases, etc.

A common concern when graphical application developers decide which APIs to use is what their **asset toolchain** will be - e.g. what tools will generate or what sources will provide the art content.
Graphical application programmers are going to be inclined to use APIs that don't require explicit conversion, or worse - require them to write the conversion code themselves.

### Graphical Framework Developers

Now let's talk about the expert graphics programmers who are building graphics libraries and frameworks, which graphical application developers use.
Those graphical application developers want to pass the assets they created in existing established foramts, such as Postscript or SVG.
For the frameworks to use the current proposed API, they would have to convert those assets to the proposed ath representation.
This would be unnecessary and inefficient, because the lower level APIs that the TS would be built on top of support those formats natively.
Additionally, since the proposed API is not as extensive as SVG or Postscript, some things will not be easily expressible using the proposed TS path representation.
Suppose we create an asset in SVG using some exotic arc type that SVG natively supports but the proposed TS does not (**TODO EXAMPLE**).
You would have to figure out how to map that primitive to the proposed TS path representation. 

Some have suggested that professional graphics programmers would use the proposed C++ 2D graphics library.
Based on the author's collective knowledge of the graphics community, we strongly believe this statement is not true.
Game/computer vision/visualization/etc developers are not going to use the proposed library.
**Graphics has its own standards, and professional graphics programmers don't want us to make another one.**

# Design Issues

## How Do I Get A Window?

**TODO: After talking with MS, not sure if we should talk about this**

## Lack of Batching Operations

**TODO: TLDR path_builder can be used to batch paths, but there's no mechanism for batching strokes and fills. This will make it inefficient to draw a scene on GPUs.**

## Doesn't Use Existing Standard Library Facilities

# Scope

The scope of this work is broader than just drawing, because there are many library features missing from C++ that a drawing library depends on.
We should focus on and prioritize these dependencies, which are of broader utility, before revisiting a proposal for a drawing library.

## Text and Unicode

N3791, the paper that began work on the proposed drawing library, it was stated that the library should be able to draw text.

The current proposal, P0267r7, has a section on text rendering and display.
The section in it's entirety is reproduced below:

> [ *Note:* Text rendering and matters related to it, such as font support, will be added at a later date. This section is a placeholder. The integration of text rendering is expected to result in the addition of member functions to the surface class and changes to other parts of the text. â€” end note ]

Why is this feature missing from the library?
It seems likely that this component of the library would depend on the standardization of a text library with Unicode support.
There is work ongoing in this space (**TODO: Paper numbers**), but it has not yet reached maturity.

How much value and utility is there in producing a drawing library that cannot draw text?

<!-- One of the examples in the paper draws "C++" using the path APIs -->

## Geometry

**TODO**

## Linear Algebra

**TODO**

<!-- **TODO: Linear Algebra (how might the HPC community feel about graphics people designing these types)** -->

# Priorities

## Committee Resources are Limited

An unfortunate reality of our work is that committee resources and time are finite.
Thus, we must prioritize and even discard proposals either explicitly, or implicitly by never giving them time.
Directions for ISO C++ (**TODO: Add Paper Number**) attempts to describes how that sorting and prioritizing should happen.

We must consider whether spending additional time on this proposal is the right investment for us.
In its current form, the proposal, which is limited to drawing shapes, is about 150 pages long.
It's one of the largst proposals currently in flight.
N3791, the paper which initiated work on a graphics proposal, stated that this feature should "ship in two years".
That was in 2013.

The proposal is still in LEWG and it seems clear that it needs additional time there before it advances, as there are many existing technical issues, some of which are detailed above.
Both at the Jacksonville 2018 meeting during the LEWG discussion of this proposal and during subsequent discussions, committee members with experience sitting in LWG estimated that it would take the equivalent of an entire meeting of LWG's time to get the proposal out for a Technical Specification. 
Assuming that estimate is roughly accurate, it indicates a substantial resource investment.
We only have nine meetings in between each International Standard.
Approximately two to three of those meetings get spent on ballot resolution, leaving about six meetings for feature development.
Are we comfortable spending 1/6th of the time that LWG would spend on an International Standard development cycle to get this feature into a Technical Specification?

There are many important library facilities that are currently missing from C++ which have greater and broader utility, such as ranges, networking, executors, text, unicode.
A number of those have been discussed in this proposal, as a drawing library depends on having these features.
Given that the committee does not have infinite time, and given that there is higher impact work that a drawing library depends on, **TODO** 

## What Belongs in The Standard?

# Alternative Proposal

If the committee feels strongly that a 2D Graphics library is a high priority, we suggest a minimal design with a thin interface:

```
namespace std { namespace graphics {
  struct display_exception;

  struct asset {
    explicit asset(string const& xml);
    explicit asset(filesystem::path const& file);
    ~asset();
  };

  template<class Function>
  static void process_events(double timeout, Function f);

  template<class T>
  struct point { T x, y; };

  template<class T>
  struct rectangle { point<T> top_left, bottom_right; };

  struct surface {
    void clear();
    void apply(asset const& a, rectangle<float> /*window subrect*/);
  };

  struct window {
    window(rectangle<int> = {}, string const& title = "");
    ~window();

    void on_key_down(function<void(int /*key code*/)> action);
    void on_key_up(function<void(int /*key code*/)> action);
    void on_pointer_pos(function<void(float /*normalized x*/, float /*normalized y*/)> action);
    void on_pointer_down(function<void(int /*button code*/)> action);
    void on_pointer_up(function<void(int /*button code*/)> action);

    void on_draw(function<void()> action);
    void on_close(function<void()> action);
    void on_place(function<void(rectangle<int>/*display subrect*/)> action);

    void place(rectangle<int>);
    void redraw();
    bool closed() const;

    void clear();
    void apply(asset const& a, rectangle<float> /*window subrect*/);

    using native_handle_type = implementation-defined;
    native_handle_type native_handle();
  };
} }
```

Objects of class `asset` encapsulate a W3C SVG graph. Constructors are provided that consume strings and files, which shall be text representations of the graph in the W3C SVG XML format. Much like objects of class `regex`, these can be parsed once and used often, to amortize the cost of constructing the graph. [ Note: Objects of class `asset` are akin to sprites. â€“ End note ]

The free-function `process_events` shall be invoked in the main thread, and repeatedly executes the following steps:
1.) Blocks waiting for the next window event, or until `timeout` seconds have elapsed.
2.) Processes all available window events.
3.) Invokes f.

Objects of class `window` encapsulate implementation-defined display windows. A display window is user-visible rectangular grid of pixels that can be the target of user interaction events, such typing, pointing, moving, resizing and closing.

The constructor `window::window` creates a visible display window with suggested screen footprint `rect` in pixels, and suggested name title. Implementations should ensure that these parameters are respected, if possible. The member functions have the following semantics:

* The member functions `window::on_*` set the event handler for different event. Each takes a `Callable` operand that replaces the previous handler, if any. [ *Note:* The only way to draw on a display window is by registering a handler with `on_draw`, in order to get access to a surface object. â€“ *end note* ]
* The member function `window::place` raises a place event on the window, with suggested screen footprint `rect`.
* The member function `window::redraw` raises a draw event on the window. [ *Note:* This causes the handler registered with `on_draw` to eventually execute. â€“ *end note* ]
* The member function `window::closed` returns true if the display window has been closed.
* The member function `window::native_handle` returns an object of type `native_handle_type` suitable for use with implementation-defined capabilities, such as advanced rendering capabilities. Implementations may require that no operation to the display window be performed through the `native_handle` once any operation has been performed through a `surface` object.

Objects of class `surface` encapsulate the rendering capabilities of a display window. A display window may only render objects of class `asset`, and only as an effect of executing a function registered with on_draw. A surface presents only two operations:
* The member function `surface::clear` invalidates the contents of the display window. The meaning of this operation is implementation-defined.
* The member function `surface::apply` renders an object of class asset with relative footprint `rect`.

**TODO: Description of the design, links to some prior art (preferrably some non-NVIDIA stuff too)**
