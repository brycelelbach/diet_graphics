<pre class='metadata'>
Title: Diet Graphics
Abstract: The proposed 2D graphics library is not a good fit for C++.
Shortname: D1062
Revision: 0
Audience: WG21
Status: D
Group: WG21
URL: http://wg21.link/P1062r0
Editor: Bryce Adelstein Lelbach, NVIDIA, brycelelbach@gmail.com
Editor: Olivier Giroux, NVIDIA, ogiroux@nvidia.com
Editor: Corentin Jabot, corentinjabot@gmail.com
Date: 2018-05-07
Markup Shorthands: markdown yes
</pre>

# Goals

Before we dive into the details, let's take a step back and discuss **why** some on the committee have a desire to standardize a C++ 2D graphics library.

A few different use cases have been identified:

* Improving the teachability of C++.
* Providing graphics programmers with a standard 2D graphics API.

## Teaching

Some of the motivation behind the proposed C++ 2D graphics interface is a desire to provide a powerful teaching tool for C++.
For new programmers, especially younger programmers, writing command line applications may not be particularly intuitive or exciting
Being able to see and interact with your code is far more natural.
Building graphical applications can help the student connect the code they are writing to the real world.
After all, most non-programmers primarily interact with software that has a graphical interface of some sort.

We agree that this is a goal that C++ should pursue.
However, we believe that the proposed C++ 2D graphics interface does not facilitate teaching.

Let's consider an example. Suppose you are teaching a group of teenagers with no programming experience how to program in C++.
There are a number of common starting points for young programmers, such as robotics, but let's consider the one that is likely most popular: building a simple game.

Suppose we want our students to start by building a simple animation (later, we'll add keyboard input in to make it a game) where a single character moves around on a 2D screen.

Where do we start?

* First, they need to get a window, and a surface in that window that they can draw in.
* Then, they need to programmatically place the character sprite on the screen at some starting position. The character sprite could be represented as an instance of a class type, whose constructor puts it in the starting position,
* Next, they'll want to move the character sprite around by progamtically updating its position and redrawing the screen. This could be done by adding methods to the character sprite class: `move_left`, `move_right`, `move_up`, `move_down`, etc.

Eventually, we'd want to replace the static animation with movement based on keyboard input.
Then we would add other sprites (other characters, obstacles, etc) and game logic for how they would interact.

What we're doing in this curriculum is **teaching programming in C++ using graphics**.

This is not something that the proposed C++ 2D graphics interfaces enables.
The proposed C++ 2D graphics interface gives you a mechanism to **programmatically draw graphics using C++".
For example, you could programmatically draw the character sprite in the above example.

But, why would you want to have students do this?
The drawing of the character is not what we want to focus on; instead we want to build application logic that programmatically manipulates different objects (**assets**) on a surface.
Instead of drawing assets programmatically in C++, we could have the students use an image editting tool to create an image (JPG, SVG, etc) to use as their sprite.

Drawing even simple images with the proposed C++ 2D graphics library is verbose and thus distracting.
If one was to design a curriculum around this proposal, students will have to learn a lot about computer graphics.
Our goal is for students to learn C++ programming; graphics should be a teaching aid, not the main focus.

For a C++ 2D graphics library to be a powerful teaching aid, it should be simple, easy to use.
It should support and leverage established graphics standards and formats, so that programmers can use common image editting tools to generate art assets instead of having to express them programmatically in C++.
 
## Enabling Graphics Programmers

There are many professional graphics programmers and who use C++, so it is natural for the committee to consider ways to help them.

There are two classes of graphics programmers:

* **Graphical Application Developers (Non-Experts)** build graphics applications, such as games. They are mainly concerned with developing application logic that manipulates graphics asset but not programmatically building the assets. The assets they work with are developed using an **asset toolchain** that generates assets in common formats such as Postscript or SVG by either the graphical application developers or artists that they collaborate with.
* **Graphical Framework Developers (Experts)** build graphics frameworks, engines, and libraries that graphical applicaiton developers use.

Naturally, there are many more graphical application developers than there are framework developers.

### Graphical Application Developers

Graphical application developers are application programmers who build (usually interactive) software which displays visual output.
Some examples of graphical games, cartography software, **TODO: More examples**. 
Most graphical application developers do not produce the art assets they use.

**TODO: Expand on graphical application developer lifestyle more. How games are build - you develop your assets in some tool, then you write the game logic that manipulates them.**

A common concern when deciding which APIs to use is what the **asset toolchain** will be - e.g. what tools will the artists be using and what format will the assets they produce be in.
Graphical application programmers are going to be inclined to use APIs that don't require explicit conversion, or worse - require them to write the conversion code themselves.

### Graphics Experts

Now let's talk about the expert graphics programmers who are building graphics libraries and frameworks, which graphical application developers use.
Those graphical application developers want to pass the assets they created in existing established foramts, such as Postscript or SVG.
For the frameworks to use the current proposed API, they would have to convert those assets to the proposed ath representation.
This would be unnecessary and inefficient, because the lower level APIs that the TS would be built on top of support those formats natively.
Additionally, since the proposed API is not as extensive as SVG or Postscript, some things will not be easily expressible using the proposed TS path representation.
Suppose we create an asset in SVG using some exotic arc type that SVG natively supports but the proposed TS does not (**TODO EXAMPLE**).
You would have to figure out how to map that primitive to the proposed TS path representation. 

Some have suggested that professional graphics programmers would use the proposed C++ 2D graphics library.
Based on the author's collective knowledge of the graphics community, we strongly believe this statement is not true.
Game/computer vision/visualization/etc developers are not going to use the proposed library.

<!-- **TODO: Summary of why.** -->

It's like we're developing a new (programmatic) asset format (the proposed path representation, etc) - and no one asked for that!
**Graphics has its own standards, and professional graphics programmers don't want us to make another one.**

We believe that the issues with the proposed C++ 2D graphics library are due to conflicting goals:

0.) It is intended to be a **high-level simple interface** that is easy for non graphics programmers to use and makes C++ more teachable.
1.) It is intended to be a **low-level complex interface** for graphics programmers.

We believe that second goal is an anti-goal.

We propose that the following goals should be adopted for a standard C++ 2D graphics API.

* **Leverage Established Graphics Standards Instead of Creating Our Own:**
* **Universally Portable:**
* **Minimal Interface:**
* **Leave Room for Efficiency:**

<!-- TODO: Less harsh name for this -->
# Current Design Flaws

<!--
## How do I get a Window?

There are some **portability pain points** that graphics programmers experience today that we could help solve.
For example - how do we get a window in a portable way?

<!-- Begin text dump from Corentin's blog. Needs to be cleaned up. -->

The first thing one need to do play with pretty pixes is to get a “surface”. A canvas where pixels get drawn.

So hopefully you have a surface class to which you give dimensions and that gets you a canvas on which to paint.

But wait. On most desktop systems, if you want a surface you need to put it in a window. It’s customary for windows to have titles so a graphics API should probably handle that, right ?

You probably also want the window to have an icon. An icon is a file on most system, the format of which is system specific. But sometime it’s not a path, it’s a name corresponding to a path.

The size of a window can change during the execution of the program on some desktop operating system.

Sometimes the window can be moved to another screen that has another resolution. And there is this weird new screens where there are virtual pixels that are bigger than true pixels ? Unless you are rendering an images or something then you should make sure you uses all the power of the small crispy pixes since the customer paid a premium for boasting about how crispy his screen is.

That woman over there was jealous so she bought a TV with 40 bits per pixels. You can’t really see the difference but are you going to tell her she wasted 5000 bucks ?

And then there is a screen in your pocket and IT ROTATES in all the directions and now the surface is all wonky. But it has no window so it has no title or icon.

What time is it ? OH GOSH THAT THING HAS A SCREEN TOO BUT IT’S SO SMALL… Better go and read a book WTF ELECTRONIC INK that you should refresh as little as possible and that only is black ?

World is crazy, right ? Let’s stick to Linux, shall we? So on Linux there is this thing called X11 which you request a surface to… oh sorry, while you are writing the paper X11 is being deprecated and now you should use Wayland… unless you rather have a frame buffer? It can be accelerated using opengl. or embedded opengl. totally different thing. But really, Vulkan is faster than both these things. Oh and on this system we prefer that you draw the windows yourself, there is a war raging on about CSD vs SSD it has been going on for years and you can’t take side.

And if you have CSD please make sure that I can drag the windows properly and I have set up sticky corners so that the windows can be aligned nicely. Make sure to handle them. Properly. And when you drag the window it should be a bit transparent, you know about windows compositing right ?

Okay so, you start to tell yourself that maybe drawing stuff is complicated. Let the implementors compiler writers and library vendors deal with all that crap. So you provide an API that works everywhere, so it handles absolutely nothing, which is to say it works nowhere.

Now the compiler writers are a bit pissed. All they wanted in life was to write compilers and there they are, trying to understand how GDI work. Plus Microsoft is maybe not really interested in providing a drawing framework, they rather have their users use the WinRT xml-based tools. Meanwhile the GCC guys are still trying to have std::thread work on windows.

Clang people get bug reports that “it doesn’t work”. People have expectations that the STL will work perfectly, consistently, anywhere

No problem. We will make the graphics library optional. So now there are bits of the Standard Library that are not standard. If and when they are implemented, they don’t behave quite the same on every platform. So now the code written using standard tools is not portable. So we need to have a copy of the STL in the repository along with messy build scripts. Back to square one.

Maybe we messed up somewhere? Let’s look at what exists on Internet. People have displays so surely they do write libraries for them, right ?

Turns out Qt is pretty popular. It does a lot more than displaying triangle though. It was released in 1995. It has strings, threads, tons of stuffs. People really did not came up with anything better since ?

wxWidgets is even older. It too has strings and threads and a lot of things that don’t have business being in a graphic library. GTK is the exact same thing.

But C++ goals are more aligned with things like SDL. Released in 1995 with threads and strings and weird things. Allegro, released in 1990. Same thing

You look at other languages. Surely the Rust community has an awesome painting framework, right ? Or the Go people ? Turns out they write wrappers around Qt, or SDL or something, like they deemed to complicated to start from scratch.

So 20 years later you manage to draw a triangle on all platforms. For some definition of all.
-->

## Efficiency

<!-- 

## Efficiency

You will never get decent efficiency out of this API because the current design prohibits an implementation that would utilize GPUs.
The current API would force frequent

Let's say we want to render a tiger. This is a complex image consisting of a variety of different paths that get stroked and filled in different colors.

The current design of the API would make this difficult to render on a GPU because 

Suppose I want to render a path with a certain render and a certain stroke

According to Mark Kilgard:

TS path == path command
TS path group (maybe now figure) == path
TS path_builder == buffer of paths

path has one stroke/fill associated with it.

```
auto sfc = make_image_surface();

path_builder pb{};

pb.new_figure({ 0.0f, 0.0f });
pb.line({ 20.0f, 10.0f });
pb.close_figure({ 0.0f, 0.0f });

sfc.stroke(brush, pb, nullopt, stroke_props{ 10.0f }, nullopt, alised);

pb.new_figure({ 0.0f, 0.0f });
pb.line({ 20.0f, 10.0f });
pb.close_figure({ 0.0f, 0.0f });

sfc.stroke(brush, pb, nullopt, stroke_props{ 10.0f }, nullopt, alised);
```

```
enum path_command {};

std::vector<path_commands> pc(M);
std::vector<path>          p(N);
std::vector<strokes>       s(N); // Color, end caps, dashed or not
std::vector<fills>         f(N); // Gradient, texture

// Turn this into one contiguous sequence of path commands:
//
// p[0] (start of path 0)
// p[1]
// p[2] (start of path 1)
// p[3]
// p[4] (start of path 2)
// p[5]
```

**TODO: Everything should be parameterized and bufferable**

**TODO: This is retained mode.**

The proposed C++ 2D graphics interface is largely an **immediate mode** interface.

However, `path_builder` is retained mode. People will want a batching mechanism that isn't retained.
-->

## TODO: Other Issues

## Scope is Broader than just 2D Graphics

**TODO: Text/Unicode**

**TODO: Geometry**

**TODO: Linear Algebra (how might the HPC community feel about graphics people designing these types)**

## Committee Resources are Limited

Committee resources and time are limited.
Thus, we must prioritize and even discard proposals either explicitly, or implicitly by never giving them time.
Directions for ISO C++ (**TODO: Add Paper Number**) attempts to describes how that sorting and prioritizing should happen.

The question then becomes: can the committee spares the time to work on a 2D graphics library and is that a priority?

In its current form, the proposal, which is limited to drawing shapes, is about 150 pages long. It's one of the largst proposals currently in flight.

At the Jacksonville 2018 meeting, during the LEWG discussion of this proposal, a library implementor with ample experience in LWG estimated that it would take the equivalent of an entire meeting of LWG's time to get the proposal out for a Technical Specification. 
Assuming that estimate is roughly accurate, it indicates a substantial resource investment.
We only have nine meetings in between each International Standard.
Approximately two to three of those meetings get spent on ballot resolution, leaving about six meetings for feature development.
Are we comfortable spending 1/6th of an International Standard development cycle on this proposal?

# Alternative Proposal

If the committee feels strongly that a 2D Graphics library is a high priority, we suggest a minimal design with a thin interface.
**TODO: Description of the design, links to some prior art (preferrably some non-NVIDIA stuff too)**

```
namespace std { namespace graphics {
  struct display_exception;

  struct asset {
    explicit asset(string const& xml);
    explicit asset(filesystem::path const& file);
    ~asset();
  };

  template<class Function>
  static void process_events(double timeout, Function f);

  template<class T>
  struct point { T x, y; };

  template<class T>
  struct rectangle { point<T> top_left, bottom_right; };

  struct window {
    window(rectangle<int> = {}, string const& title = "");
    ~window();

    void on_key_down(function<void(int /*key code*/)> action);
    void on_key_up(function<void(int /*key code*/)> action);
    void on_pointer_pos(function<void(float /*normalized x*/, float /*normalized y*/)> action);
    void on_pointer_down(function<void(int /*button code*/)> action);
    void on_pointer_up(function<void(int /*button code*/)> action);

    void on_draw(function<void()> action);
    void on_close(function<void()> action);
    void on_place(function<void(rectangle<int>/*display subrect*/)> action);

    void place(rectangle<int>);
    void redraw();
    bool closed() const;

    void clear();
    void apply(asset const& a, rectangle<float> /*window subrect*/);

    using native_handle_type = implementation-defined;
    native_handle_type native_handle();
  };
} }
```

**TODO: Olivier should add some words describing how things work.**

